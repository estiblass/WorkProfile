name: WorkProfile CI/CD Pipeline

on:
  push:
    branches:
      - main

jobs:
  # Stage 1: Basic Validation
  basic-validation:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.x'

      - name: Install Python dependencies
        run: |
          python3 -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Basic validation tests
        run: |
          python3 -c "import flask; print('✓ Flask import successful')"
          python3 -c "import mysql.connector; print('✓ MySQL connector import successful')"
          test -f Dockerfile && echo "✓ Dockerfile exists"
          test -f requirements.txt && echo "✓ requirements.txt exists"
          test -f app.py && echo "✓ app.py exists"

  # Stage 2: Build and Test Application
  build-and-test:
    needs: basic-validation
    runs-on: ubuntu-latest
    env:
      IMAGE_TAG: 1.0.${{ github.run_number }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Build Docker image
        run: |
          docker build -t esti563/workprofile:${{ env.IMAGE_TAG }} .
          docker tag esti563/workprofile:${{ env.IMAGE_TAG }} esti563/workprofile:latest

      - name: Run single container tests
        run: |
          docker run -d -p 5000:5000 --name test-app esti563/workprofile:${{ env.IMAGE_TAG }}
          sleep 15
          curl -f http://localhost:5000/ && echo "✓ Main endpoint works"
          curl -f http://localhost:5000/health && echo "✓ Health endpoint works"
          docker stop test-app && docker rm test-app

  # Stage 3: 3-Tier Stack Testing with Docker Compose
  docker-compose-test:
    needs: build-and-test
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Install Docker Compose
        run: |
          sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
          sudo chmod +x /usr/local/bin/docker-compose
          docker-compose --version

      - name: Run 3-tier Docker Compose stack
        run: |
          cd docker-compose
          docker-compose up -d
          sleep 90
          curl -f http://localhost:8080/ && echo "✓ Nginx proxy works"
          curl -f http://localhost:8080/health && echo "✓ Health through nginx works"
          curl -s http://localhost:8080/health | grep "Database: Healthy" && echo "✓ Database connectivity works"
          docker-compose down -v

  # Stage 4: Publish Docker Images
  publish:
    needs: docker-compose-test
    runs-on: ubuntu-latest
    env:
      IMAGE_TAG: 1.0.${{ github.run_number }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Log in to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Build and push Docker images
        run: |
          docker build -t esti563/workprofile:${{ env.IMAGE_TAG }} .
          docker tag esti563/workprofile:${{ env.IMAGE_TAG }} esti563/workprofile:latest
          docker push esti563/workprofile:${{ env.IMAGE_TAG }}
          docker push esti563/workprofile:latest

  # Stage 5: Kubernetes Deployment Testing (פעיל עם pull מה-Docker Hub)
  kubernetes-test:
    needs: publish
    runs-on: ubuntu-latest
    env:
      IMAGE_TAG: 1.0.${{ github.run_number }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup kind cluster
        uses: helm/kind-action@v1.8.0
        with:
          version: v0.20.0
          cluster_name: kind
          wait: 300s

      - name: Pull image from Docker Hub and load into kind
        run: |
          docker pull esti563/workprofile:${{ env.IMAGE_TAG }}
          kind load docker-image esti563/workprofile:${{ env.IMAGE_TAG }}

      - name: Deploy MySQL manifests
        run: |
          kubectl apply -f k8s/mysql-secret.yaml
          kubectl apply -f k8s/mysql-statefulset.yaml
          kubectl apply -f k8s/mysql-service.yaml
          kubectl wait --for=condition=ready pod/mysql-0 --timeout=600s

      - name: Deploy WorkProfile manifests
        run: |
          kubectl apply -f k8s/workprofile-configmap.yaml
          kubectl apply -f k8s/workprofile-deployment.yaml
          kubectl apply -f k8s/workprofile-service.yaml
          kubectl wait --for=condition=available deployment/workprofile --timeout=600s

      - name: Test WorkProfile app in Kubernetes
        run: |
          kubectl port-forward deployment/workprofile 5000:5000 &
          FORWARD_PID=$!
          sleep 20
          curl -f http://localhost:5000/ && echo "✓ Kubernetes app works"
          curl -f http://localhost:5000/health && echo "✓ Kubernetes health works"
          curl -s http://localhost:5000/health | grep "Database: Healthy" && echo "✓ Kubernetes database works"
          kill $FORWARD_PID

  # Stage 6: Manual Deployment Instructions
  manual-deploy-instructions:
    needs: publish
    runs-on: ubuntu-latest
    steps:
      - name: Display manual deployment instructions
        run: |
          echo "Deploy the manifests to your Killercoda environment with:"
          echo "kubectl apply -f k8s/mysql-secret.yaml"
          echo "kubectl apply -f k8s/mysql-statefulset.yaml"
          echo "kubectl apply -f k8s/mysql-service.yaml"
          echo "kubectl apply -f k8s/workprofile-configmap.yaml"
          echo "kubectl apply -f k8s/workprofile-deployment.yaml"
          echo "kubectl apply -f k8s/workprofile-service.yaml"
          echo ""
          echo "Wait for pods to be ready and verify deployment with:"
          echo "kubectl get pods"
          echo "kubectl get statefulset"
          echo "kubectl get pvc"
          echo ""
          echo "Use kubectl port-forward or NodePort to access the application."
