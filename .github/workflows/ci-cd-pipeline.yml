name: WorkProfile CI/CD Pipeline

on:
  push:
    branches:
      - main

jobs:
  # Stage 1: Basic Validation
  basic-validation:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-python@v4
        with:
          python-version: '3.x'
      - run: |
          python3 -m pip install --upgrade pip
          pip install -r requirements.txt
      - run: |
          python3 -c "import flask; print('✓ Flask import successful')"
          python3 -c "import mysql.connector; print('✓ MySQL connector import successful')"
          test -f Dockerfile && echo "✓ Dockerfile exists"
          test -f requirements.txt && echo "✓ requirements.txt exists"
          test -f app.py && echo "✓ app.py exists"

  # Stage 2: Build and Test Application
  build-and-test:
    needs: basic-validation
    runs-on: ubuntu-latest
    env:
      IMAGE_TAG: 1.0.${{ github.run_number }}
    steps:
      - uses: actions/checkout@v3
      - run: |
          docker build -t esti563/workprofile:${{ env.IMAGE_TAG }} .
          docker tag esti563/workprofile:${{ env.IMAGE_TAG }} esti563/workprofile:latest
      - run: |
          docker run -d -p 5000:5000 --name test-app esti563/workprofile:${{ env.IMAGE_TAG }}
          sleep 15
          curl -f http://localhost:5000/ && echo "✓ Main endpoint works"
          curl -f http://localhost:5000/health && echo "✓ Health endpoint works"
          docker stop test-app && docker rm test-app

  # Stage 3: 3-Tier Stack Testing with Docker Compose
  docker-compose-test:
    needs: build-and-test
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - run: |
          sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
          sudo chmod +x /usr/local/bin/docker-compose
          docker-compose --version
      - run: |
          cd docker-compose
          docker-compose up -d
          sleep 90
          curl -f http://localhost:8080/ && echo "✓ Nginx proxy works"
          curl -f http://localhost:8080/health && echo "✓ Health through nginx works"
          curl -s http://localhost:8080/health | grep "Database: Healthy" && echo "✓ Database connectivity works"
          docker-compose down -v

  # Stage 4: Publish Docker Images
  publish:
    needs: docker-compose-test
    runs-on: ubuntu-latest
    env:
      IMAGE_TAG: 1.0.${{ github.run_number }}
    steps:
      - uses: actions/checkout@v3
      - uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}
      - run: |
          docker build -t esti563/workprofile:${{ env.IMAGE_TAG }} .
          docker tag esti563/workprofile:${{ env.IMAGE_TAG }} esti563/workprofile:latest
          docker push esti563/workprofile:${{ env.IMAGE_TAG }}
          docker push esti563/workprofile:latest

  # Stage 5: Kubernetes Deployment Testing
  kubernetes-test:
    needs: publish
    runs-on: ubuntu-latest
    env:
      IMAGE_TAG: 1.0.${{ github.run_number }}
    steps:
      - uses: actions/checkout@v3
      - uses: helm/kind-action@v1.8.0
        with:
          version: v0.20.0
          cluster_name: kind
          wait: 300s
      - run: |
          docker pull esti563/workprofile:${{ env.IMAGE_TAG }}
          kind load docker-image esti563/workprofile:${{ env.IMAGE_TAG }}
      - run: |
          kubectl apply -f k8s/mysql-secret.yaml
          kubectl apply -f k8s/mysql-statefulset.yaml
          kubectl apply -f k8s/mysql-service.yaml
      - run: |
          echo "Sleeping 120s to allow MySQL pod to start..."
          sleep 120
          kubectl get pods
          kubectl logs pod/mysql-0 --all-containers || true
      - run: |
          kubectl apply -f k8s/workprofile-configmap.yaml
          kubectl apply -f k8s/workprofile-deployment.yaml
          kubectl apply -f k8s/workprofile-service.yaml
          kubectl wait --for=condition=available deployment/workprofile --timeout=600s
      - run: |
          kubectl port-forward deployment/workprofile 5000:5000 &
          FORWARD_PID=$!
          sleep 20
          curl -f http://localhost:5000/ && echo "✓ Kubernetes app works"
          curl -f http://localhost:5000/health && echo "✓ Kubernetes health works"
          curl -s http://localhost:5000/health | grep "Database: Healthy" && echo "✓ Kubernetes database works"
          kill $FORWARD_PID

  # Stage 6: Manual Deployment Instructions
  manual-deploy-instructions:
    needs: publish
    runs-on: ubuntu-latest
    steps:
      - run: |
          echo "Deploy the manifests to Killercoda with:"
          echo "kubectl apply -f k8s/mysql-secret.yaml"
          echo "kubectl apply -f k8s/mysql-statefulset.yaml"
          echo "kubectl apply -f k8s/mysql-service.yaml"
          echo "kubectl apply -f k8s/workprofile-configmap.yaml"
          echo "kubectl apply -f k8s/workprofile-deployment.yaml"
          echo "kubectl apply -f k8s/workprofile-service.yaml"
          echo "Verify pods with: kubectl get pods, kubectl get statefulset, kubectl get pvc"
          echo "Use port-forward or NodePort to access the app."
